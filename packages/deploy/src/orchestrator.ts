import { GitHubClient } from './github';
import { CloudflareClient } from './cloudflare';
import { EASClient } from './eas';
import type { DeploymentResult } from './types';

export interface OrchestratorConfig {
  github: {
    token: string;
    owner?: string;
  };
  cloudflare: {
    apiToken: string;
    accountId: string;
  };
  eas?: {
    token: string;
  };
}

export interface DeployOptions {
  projectId: string;
  projectName: string;
  files: Record<string, string>;
  platforms: Array<'web' | 'api' | 'mobile'>;
  secrets?: Record<string, string>;
  environment?: 'preview' | 'production';
}

export interface DeployResult {
  github: { url: string; sha: string };
  deployments?: DeploymentResult[];
}

export class DeploymentOrchestrator {
  private github: GitHubClient;
  private cloudflare: CloudflareClient;
  private eas?: EASClient;

  constructor(config: OrchestratorConfig) {
    this.github = new GitHubClient(config.github.token, config.github.owner);
    this.cloudflare = new CloudflareClient(config.cloudflare.apiToken, config.cloudflare.accountId);
    if (config.eas?.token) {
      this.eas = new EASClient(config.eas.token);
    }
  }

  /**
   * Initialize the orchestrator
   */
  async init(): Promise<void> {
    await this.github.init();
  }

  /**
   * Full deployment pipeline
   */
  async deploy(options: DeployOptions): Promise<DeployResult> {
    const results: DeploymentResult[] = [];
    const repoName = this.sanitizeRepoName(options.projectName);

    // Step 1: Create/update GitHub repository
    console.log(`Creating GitHub repository: ${repoName}`);
    const repoExists = await this.github.repoExists(repoName);
    if (!repoExists) {
      await this.github.createRepo({
        name: repoName,
        description: `Generated by Definitely Not AI - Project: ${options.projectId}`,
        private: true,
      });
    }

    // Step 2: Push code to repository
    console.log('Pushing code to repository...');
    const { sha } = await this.github.pushFiles(
      repoName,
      options.files,
      `Deploy: ${new Date().toISOString()}`
    );

    // Step 3: Set secrets if provided
    if (options.secrets && Object.keys(options.secrets).length > 0) {
      console.log('Setting repository secrets...');
      await this.github.setSecrets(repoName, options.secrets);
    }

    // Step 4: Deploy to each platform
    for (const platform of options.platforms) {
      console.log(`Deploying to ${platform}...`);
      switch (platform) {
        case 'web': {
          const webResult = await this.deployWeb(repoName, options);
          results.push(webResult);
          break;
        }
        case 'api': {
          const apiResult = await this.deployAPI(repoName, options);
          results.push(apiResult);
          break;
        }
        case 'mobile':
          if (this.eas) {
            const mobileResult = await this.deployMobile();
            results.push(mobileResult);
          } else {
            results.push({
              success: false,
              platform: 'eas',
              error: 'EAS not configured - missing EXPO_TOKEN',
            });
          }
          break;
      }
    }

    const repoInfo = await this.github.getRepo(repoName);

    return {
      github: { url: repoInfo.url, sha },
      deployments: results,
    };
  }

  /**
   * Deploy web app to Cloudflare Pages
   */
  private async deployWeb(repoName: string, options: DeployOptions): Promise<DeploymentResult> {
    // Check if project exists, create if not
    const exists = await this.cloudflare.pagesProjectExists(repoName);
    if (!exists) {
      await this.cloudflare.createPagesProject({
        name: repoName,
        productionBranch: 'main',
        buildCommand: 'bun run build',
        buildOutputDirectory: 'build',
      });
    }

    // Set environment variables
    if (options.secrets) {
      await this.cloudflare.setPagesEnvironmentVariables(
        repoName,
        options.secrets,
        options.environment || 'production'
      );
    }

    // Create GitHub workflow for automatic deployments
    await this.github.createWorkflow(repoName, 'pages', { outputDir: 'build' });

    // For immediate deployment, use direct upload
    // Filter to only web-relevant files
    const webFiles = Object.fromEntries(
      Object.entries(options.files).filter(([path]) =>
        path.startsWith('build/') ||
        path.startsWith('.svelte-kit/') ||
        path === 'package.json'
      )
    );

    // If no build output, return success (CI will deploy on push)
    if (Object.keys(webFiles).length === 0) {
      return {
        success: true,
        platform: 'cloudflare-pages',
        url: `https://${repoName}.pages.dev`,
        logs: ['Deployment configured - will deploy on next push'],
      };
    }

    return await this.cloudflare.deployToPages(repoName, webFiles);
  }

  /**
   * Deploy API to Cloudflare Workers
   */
  private async deployAPI(repoName: string, options: DeployOptions): Promise<DeploymentResult> {
    const workerName = `${repoName}-api`;

    // Find the main worker file
    const workerFile = options.files['dist/index.js'] ||
                       options.files['src/index.ts'] ||
                       options.files['index.js'];

    if (!workerFile) {
      return {
        success: false,
        platform: 'cloudflare-workers',
        error: 'No worker entry point found',
      };
    }

    // Create GitHub workflow for automatic deployments
    await this.github.createWorkflow(repoName, 'workers', {});

    // Deploy worker
    return await this.cloudflare.deployWorker(
      workerName,
      workerFile,
      options.secrets ? { vars: options.secrets } : undefined
    );
  }

  /**
   * Deploy mobile app via EAS
   */
  private async deployMobile(): Promise<DeploymentResult> {
    if (!this.eas) {
      return {
        success: false,
        platform: 'eas',
        error: 'EAS client not initialized',
      };
    }

    // EAS builds from the repository, so we just trigger the build
    // The code has already been pushed to GitHub
    // For now, return instructions
    return {
      success: true,
      platform: 'eas',
      logs: [
        'Mobile build configured.',
        'To build locally: cd mobile && eas build --platform all',
        'GitHub Actions will build on push to main branch',
      ],
    };
  }

  /**
   * Quick deploy - just push and let CI handle deployment
   */
  async quickDeploy(options: DeployOptions): Promise<{ github: { url: string; sha: string } }> {
    const repoName = this.sanitizeRepoName(options.projectName);
    const repoExists = await this.github.repoExists(repoName);

    if (!repoExists) {
      await this.github.createRepo({
        name: repoName,
        description: `Generated by Definitely Not AI`,
        private: true,
      });
    }

    const { sha } = await this.github.pushFiles(
      repoName,
      options.files,
      `Deploy: ${new Date().toISOString()}`
    );

    if (options.secrets) {
      await this.github.setSecrets(repoName, options.secrets);
    }

    const repoInfo = await this.github.getRepo(repoName);

    return { github: { url: repoInfo.url, sha } };
  }

  private sanitizeRepoName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/--+/g, '-')
      .replace(/^-|-$/g, '')
      .slice(0, 100);
  }
}
