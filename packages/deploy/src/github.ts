import { Octokit } from '@octokit/rest';
import type { GitHubRepoConfig } from './types';

export class GitHubClient {
  private octokit: Octokit;
  private owner: string;

  constructor(token: string, owner?: string) {
    this.octokit = new Octokit({ auth: token });
    this.owner = owner || ''; // Will be set from authenticated user
  }

  /**
   * Initialize and get authenticated user
   */
  async init(): Promise<string> {
    const { data: user } = await this.octokit.users.getAuthenticated();
    this.owner = user.login;
    return this.owner;
  }

  /**
   * Create a new repository
   */
  async createRepo(config: GitHubRepoConfig): Promise<{ owner: string; name: string; url: string }> {
    const { data: repo } = await this.octokit.repos.createForAuthenticatedUser({
      name: config.name,
      description: config.description || `Generated by Definitely Not AI`,
      private: config.private ?? true,
      auto_init: config.autoInit ?? false,
    });

    return {
      owner: repo.owner.login,
      name: repo.name,
      url: repo.html_url,
    };
  }

  /**
   * Check if repository exists
   */
  async repoExists(name: string): Promise<boolean> {
    try {
      await this.octokit.repos.get({ owner: this.owner, repo: name });
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Push files to repository
   */
  async pushFiles(
    repoName: string,
    files: Record<string, string>,
    message: string = 'Initial commit from Definitely Not AI',
    branch: string = 'main'
  ): Promise<{ sha: string }> {
    // Get the current commit SHA (or create initial commit)
    let baseSha: string | undefined;
    try {
      const { data: ref } = await this.octokit.git.getRef({
        owner: this.owner,
        repo: repoName,
        ref: `heads/${branch}`,
      });
      baseSha = ref.object.sha;
    } catch {
      // Branch doesn't exist yet, will create
    }

    // Create blobs for each file
    const blobs = await Promise.all(
      Object.entries(files).map(async ([path, content]) => {
        const { data: blob } = await this.octokit.git.createBlob({
          owner: this.owner,
          repo: repoName,
          content: Buffer.from(content).toString('base64'),
          encoding: 'base64',
        });
        return { path, sha: blob.sha };
      })
    );

    // Create tree
    const { data: tree } = await this.octokit.git.createTree({
      owner: this.owner,
      repo: repoName,
      tree: blobs.map(({ path, sha }) => ({
        path,
        mode: '100644',
        type: 'blob',
        sha,
      })),
      ...(baseSha ? { base_tree: baseSha } : {}),
    });

    // Create commit
    const { data: commit } = await this.octokit.git.createCommit({
      owner: this.owner,
      repo: repoName,
      message,
      tree: tree.sha,
      parents: baseSha ? [baseSha] : [],
    });

    // Update or create branch reference
    if (baseSha) {
      await this.octokit.git.updateRef({
        owner: this.owner,
        repo: repoName,
        ref: `heads/${branch}`,
        sha: commit.sha,
      });
    } else {
      await this.octokit.git.createRef({
        owner: this.owner,
        repo: repoName,
        ref: `refs/heads/${branch}`,
        sha: commit.sha,
      });
    }

    return { sha: commit.sha };
  }

  /**
   * Set repository secrets
   */
  async setSecrets(repoName: string, secrets: Record<string, string>): Promise<void> {
    // Get repository public key for encryption
    const { data: publicKey } = await this.octokit.actions.getRepoPublicKey({
      owner: this.owner,
      repo: repoName,
    });

    // Encrypt and set each secret
    for (const [name, value] of Object.entries(secrets)) {
      await this.octokit.actions.createOrUpdateRepoSecret({
        owner: this.owner,
        repo: repoName,
        secret_name: name,
        encrypted_value: await this.encryptSecret(value, publicKey.key),
        key_id: publicKey.key_id,
      });
    }
  }

  /**
   * Encrypt a secret value using the repository's public key
   */
  private async encryptSecret(value: string, publicKey: string): Promise<string> {
    const sodium = await import('tweetsodium');
    const messageBytes = Buffer.from(value);
    const keyBytes = Buffer.from(publicKey, 'base64');
    const encryptedBytes = sodium.seal(messageBytes, keyBytes);
    return Buffer.from(encryptedBytes).toString('base64');
  }

  /**
   * Create GitHub Actions workflow file
   */
  async createWorkflow(
    repoName: string,
    platform: 'pages' | 'workers',
    config: { buildCommand?: string; outputDir?: string }
  ): Promise<void> {
    const workflow = this.generateWorkflow(platform, config);
    await this.pushFiles(
      repoName,
      { '.github/workflows/deploy.yml': workflow },
      'Add deployment workflow'
    );
  }

  private generateWorkflow(platform: 'pages' | 'workers', config: { outputDir?: string }): string {
    if (platform === 'pages') {
      return `name: Deploy to Cloudflare Pages
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      - run: bun install
      - run: bun run build
      - name: Deploy to Cloudflare Pages
        uses: cloudflare/pages-action@v1
        with:
          apiToken: \${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: \${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          projectName: \${{ github.event.repository.name }}
          directory: ${config.outputDir || 'build'}
          gitHubToken: \${{ secrets.GITHUB_TOKEN }}
`;
    } else {
      return `name: Deploy to Cloudflare Workers
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      - run: bun install
      - name: Deploy to Cloudflare Workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: \${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: \${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
`;
    }
  }

  /**
   * Get repository details
   */
  async getRepo(name: string): Promise<{ url: string; defaultBranch: string; private: boolean }> {
    const { data: repo } = await this.octokit.repos.get({
      owner: this.owner,
      repo: name,
    });

    return {
      url: repo.html_url,
      defaultBranch: repo.default_branch,
      private: repo.private,
    };
  }
}
